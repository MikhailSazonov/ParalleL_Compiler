#include "base.hpp"

#include "../errors.hpp"

#include "io.hpp"
#include "operators.hpp"

bool BaseLib::CheckTypeExistance(const std::string& type) {
    // TODO
    return true;
}

std::optional<BaseLib::NativeDesc> BaseLib::GetNative(const std::string& name) {
    std::optional<BaseLib::NativeDesc> result;
    if ((result = BaseLib::Io::GetNative(name)).has_value()) {
        return result;
    }
    return BaseLib::Ops::GetNative(name);
}

void BaseLib::LoadBaseTypes(Def::TypeTable& typeTable) {
    typeTable["main"] = std::make_shared<Pod>("Void");
    BaseLib::Io::LoadBaseTypes(typeTable);
    BaseLib::Ops::LoadBaseTypes(typeTable);
}

std::string BaseLib::GetBaseCode() {
//    return "#include <tuple>\n"
//           "#include <memory>\n"
//           "\n"
//           "\n"
//           "template <typename F, typename... Args>\n"
//           "struct Data {\n"
//           "    void* ptr;\n"
//           "    F* fun;\n"
//           "    std::tuple<Args...> args;\n"
//           "};\n"
//           "\n"
//           "\n"
//           "template <typename T>\n"
//           "struct EmptyDeleter {\n"
//           "    void operator()(T*) {}\n"
//           "};\n"
//           "\n"
//           "\n"
//           "template <typename T, typename U>\n"
//           "struct Func {\n"
//           "    struct ControlBlock {\n"
//           "        virtual U Call(T&&) = 0;\n"
//           "    };\n"
//           "\n"
//           "    template <typename F, size_t idx, typename... Args>\n"
//           "    struct FunctionBlock : public ControlBlock {\n"
//           "        U Call(T&& arg) {\n"
//           "            auto* data = (Data<F, Args...>*)((void*)this);\n"
//           "            std::get<idx>(data->args) = std::move(arg);\n"
//           "            return U{}.template Set<F, idx + 1, Args...>(data);\n"
//           "        }\n"
//           "    };\n"
//           "\n"
//           "    Func() = default;\n"
//           "\n"
//           "    template <typename F, typename... Args>\n"
//           "    Func(Data<F, Args...>* data) : fn(new(&data->ptr) FunctionBlock<F, 0, Args...>(),\n"
//           "                                      EmptyDeleter<FunctionBlock<F, 0, Args...>>{}) {}\n"
//           "\n"
//           "    U Eval(T&& arg) {\n"
//           "        return fn->Call(std::move(arg));\n"
//           "    }\n"
//           "\n"
//           "    template <typename F, size_t idx, typename... Args>\n"
//           "    auto Set(Data<F, Args...>* data) && {\n"
//           "        fn.template reset(new(&data->ptr) FunctionBlock<F, idx, Args...>(),\n"
//           "                          EmptyDeleter<FunctionBlock<F, idx, Args...>>{});\n"
//           "        return *this;\n"
//           "    }\n"
//           "\n"
//           "    std::shared_ptr<ControlBlock> fn;\n"
//           "};\n"
//           "\n"
//           "\n"
//           "template <typename U>\n"
//           "struct Func<void, U> {\n"
//           "    struct ControlBlock {\n"
//           "        virtual U Call() = 0;\n"
//           "    };\n"
//           "\n"
//           "    template <typename F, size_t idx, typename... Args>\n"
//           "    struct FunctionBlock : public ControlBlock {\n"
//           "        U Call() {\n"
//           "            auto* data = (Data<F, Args...>*)((void*)this);\n"
//           "            return data->fun(data->args);\n"
//           "        }\n"
//           "    };\n"
//           "\n"
//           "    template <typename F, size_t idx, typename... Args>\n"
//           "    auto Set(Data<F, Args...>* data) {\n"
//           "        fn.template reset(new(&data->ptr) FunctionBlock<F, idx, Args...>(),\n"
//           "                          EmptyDeleter<FunctionBlock<F, idx, Args...>>{});\n"
//           "        return *this;\n"
//           "    }\n"
//           "\n"
//           "    U Eval() {\n"
//           "        return fn->Call();\n"
//           "    }\n"
//           "\n"
//           "    std::shared_ptr<ControlBlock> fn;\n"
//           "};\n"
//           "\n"
//           "\n"
//           "template <>\n"
//           "struct Func<void, void> {\n"
//           "    struct ControlBlock {\n"
//           "        virtual void Call() = 0;\n"
//           "    };\n"
//           "\n"
//           "    template <typename F, size_t idx, typename... Args>\n"
//           "    struct FunctionBlock : public ControlBlock {\n"
//           "        void Call() {\n"
//           "            auto* data = (Data<F, Args...>*)((void*)this);\n"
//           "            data->fun(data->args);\n"
//           "        }\n"
//           "    };\n"
//           "\n"
//           "    void Eval() {\n"
//           "        return fn->Call();\n"
//           "    }\n"
//           "\n"
//           "    template <typename F, size_t idx, typename... Args>\n"
//           "    auto Set(Data<F, Args...>* data) {\n"
//           "        fn.template reset(new(&data->ptr) FunctionBlock<F, idx, Args...>(),\n"
//           "                          EmptyDeleter<FunctionBlock<F, idx, Args...>>{});\n"
//           "        return *this;\n"
//           "    }\n"
//           "\n"
//           "    std::shared_ptr<ControlBlock> fn;\n"
//           "};\n";
    return "#include <tuple>\n"
           "\n"
           "\n"
           "template <typename R, typename... Args>\n"
           "struct Data {\n"
           "    void* ptr;\n"
           "    R(*fun)(std::tuple<Args...>&);\n"
           "    std::tuple<Args...> args;\n"
           "};\n"
           "\n"
           "\n"
           "template <typename T, typename U>\n"
           "struct Func {\n"
           "    struct ControlBlock {\n"
           "        virtual U Call(T&&) = 0;\n"
           "    };\n"
           "\n"
           "    template <typename R, size_t idx, typename... Args>\n"
           "    struct FunctionBlock : public ControlBlock {\n"
           "        U Call(T&& arg) {\n"
           "            auto* data = GetData();\n"
           "            std::get<idx>(data->args) = std::move(arg);\n"
           "            if constexpr(std::is_same_v<U, R>) {\n"
           "                return data->fun(data->args);\n"
           "            } else {\n"
           "                return U{}.template Set<R, idx + 1, Args...>(data);\n"
           "            }\n"
           "        }\n"
           "\n"
           "        Data<R, Args...>* GetData() {\n"
           "            return (Data<R, Args...>*)((void*)this);\n"
           "        }\n"
           "    };\n"
           "\n"
           "    Func() = default;\n"
           "\n"
           "    template <typename R, typename... Args>\n"
           "    Func(Data<R, Args...>* data) : fn(new(&data->ptr) FunctionBlock<R, 0, Args...>()) {}\n"
           "\n"
           "    U Eval(T&& arg) {\n"
           "        return fn->Call(std::move(arg));\n"
           "    }\n"
           "\n"
           "    auto&& Eval() {\n"
           "        return std::move(*this);\n"
           "    }\n"
           "\n"
           "    template <typename F, size_t idx, typename... Args>\n"
           "    auto Set(Data<F, Args...>* data) && {\n"
           "        fn = new(&data->ptr) FunctionBlock<F, idx, Args...>();\n"
           "        return *this;\n"
           "    }\n"
           "\n"
           "    ControlBlock* fn;\n"
           "};\n"
           "\n"
           "\n"
           "template <typename U>\n"
           "struct Func<void, U> {\n"
           "    struct ControlBlock {\n"
           "        virtual U Call() = 0;\n"
           "    };\n"
           "\n"
           "    template <typename F, size_t idx, typename... Args>\n"
           "    struct FunctionBlock : public ControlBlock {\n"
           "        U Call() {\n"
           "            auto* data = (Data<F, Args...>*)((void*)this);\n"
           "            return data->fun(data->args);\n"
           "        }\n"
           "    };\n"
           "\n"
           "    template <typename F, size_t idx, typename... Args>\n"
           "    auto Set(Data<F, Args...>* data) {\n"
           "        fn = new(&data->ptr) FunctionBlock<F, idx, Args...>();\n"
           "        return *this;\n"
           "    }\n"
           "\n"
           "    U Eval() {\n"
           "        return fn->Call();\n"
           "    }\n"
           "\n"
           "    ControlBlock* fn;\n"
           "};\n";
}
